package plugin

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"net"
	"net/rpc"
	"os"
	"reflect"

	"github.com/rjeczalik/flyingexec/util"
)

type Plugin interface {
	Init(routerAddr string, version *string) error
}

type Connector struct {
	ID       string
	Addr     string
	Listener net.Listener
}

func (c *Connector) serve(p Plugin) {
	srv := rpc.NewServer()
	srv.Register(p)
	for {
		conn, err := c.Listener.Accept()
		if err != nil {
			log.Println(err)
			continue
		}
		go srv.ServeConn(conn)
	}
}

func (c *Connector) register(p Plugin) (err error) {
	_, port, err := net.SplitHostPort(c.Listener.Addr().String())
	if err != nil {
		return
	}
	conn, err := util.DefaultNet.Dial("tcp", c.Addr)
	if err != nil {
		return
	}
	cli := rpc.NewClient(conn)
	defer cli.Close()
	req := map[string]string{
		"ID":      c.ID,
		"Port":    port,
		"Service": reflect.TypeOf(p).Elem().Name(),
	}
	err = cli.Call("__ControlService.Register", req, nil)
	return
}

// TODO it may be more correct to decouple Connector and flag parsing
func (c *Connector) parse(args []string) (err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()
	f := flag.NewFlagSet(args[0], flag.PanicOnError)
	f.StringVar(&c.ID, "id", "", "unique id generated by a router")
	f.StringVar(&c.Addr, "addr", "", "router's control service address")
	if err = f.Parse(args[1:]); err != nil {
		return
	}
	if c.ID == "" {
		return errors.New("connector: no value provided for -id flag")
	}
	if c.Addr == "" {
		return errors.New("connector: no value provided for -addr flag")
	}
	return
}

func newConnector(args []string) (c *Connector, err error) {
	c = new(Connector)
	if err = c.parse(args); err != nil {
		return
	}
	c.Listener, err = util.DefaultNet.Listen("tcp", "localhost:0")
	return
}

func NewConnector(id, addr string) (*Connector, error) {
	return newConnector([]string{os.Args[0], "-id", id, "-addr", addr})
}

func ConnectAndServe(p Plugin) error {
	c, err := newConnector(os.Args)
	if err != nil {
		return err
	}
	return Serve(c, p)
}

// TODO refactor Serve into (*Connector).Serve and (*Connector).Stop
func Serve(c *Connector, p Plugin) (err error) {
	go c.serve(p)
	defer c.Listener.Close()
	if err = c.register(p); err != nil {
		return
	}
	select {}
}
